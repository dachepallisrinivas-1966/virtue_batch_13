--------------------------------------------------------------------------------------------------------------------------------------------

D.Srinivas | dachepallisrinivas@gmail.com | 630 573 0633 (call/whatsapp)

--------------------------------------------------------------------------------------------------------------------------------------------
1) 30-dec-2021


Software links:
+	JDK 1.8
	https://www.oracle.com/in/java/technologies/javase/javase8u211-later-archive-downloads.html

+	Eclipse Enterprise Edition IDE
	https://www.eclipse.org/downloads/packages/release/neon/3/eclipse-ide-java-ee-developers

+	Oracle 11g express edition
	https://www.oracle.com/database/technologies/xe-prior-release-downloads.html

+	SQL Developer tool
	https://www.oracle.com/tools/downloads/sqldev-downloads.html
	download windows 32-bit/64-bit

+	Apache Tomcat 
	https://tomcat.apache.org/download-90.cgi














									Core Java
									----------

What is Java?
+	it is strictly, but partially object oriented programming language.

Who developed Java?
+	James Gosling at Sun microsystems (It was taken over by Oracle Corp.)


Features of Java:
-----------------
+	platform independent
+	robust
+	secured
+	object oriented



+	multi threaded
+	compiled-and-interpreted
+	dynamic
+	simple
+	high performance
+	distributed
+	persistence	(using IOStreams)


1) platform independent?
+	here platform means O/S.



sample.java				sample.class

(source code)		compiler	(byte code)



bytecode can be given to any O/S, so that it can be executed.
is bytecode in 0's and 1's?	
	NO
bytecode is also an intermediate. it is not targeted to any O/S. it is targeted to JVM.
bytecode is understood only by JVM. (Java Virtual Machine)


sample.class			►	JVM	►	O/S
(byte code)					




what is JDK, JRE and JVM?

JDK 	►	Java Development Kit		
JRE	►	Java Runtime Environment
JVM	►	Java Virtual Machine


JDK = JRE + development tools
JRE = JVM + libraries 



development tools:
+	javac
+	java
+	etc.,


JRE will create JVM on-the-fly whenever a program is executed.
once the program is done, the JVM is removed.


is JDK platform independent?
NO

is JRE platform independent?
NO

is JVM platform independent?
NO


only the BYTECODE generated is PLATFORM INDEPENDENT.
the bytecode is given to jvm. jvm will convert the bytecode into native machine code (0's, 1's)


2) secured?
+	no explicit pointers
+	program is executed only inside a jvm.
	(jvm  collection of programs - class loader, bytecode verifier, garbage collector etc.,)


3) robust?
	robust means strong, vigour and healthy

+	strong type checking mechanism
+	exception handling
+	automatic memory management


Coding Standards (Best Practices)
+	indentation
+	naming convensions


Java Tokens?
+	smallest part of the program.
	a) identifiers
	b) operators
	c) keywords
	d) literals
	e) comments


1)	identifiers
	-	name given to variables, classes, methods etc.,

	-	Pascal Notation		:	first letter of every word in upper case and the rest in lower case
						eg: class names, interface names etc.,

						eg: ArrayIndexOutOfBoundsException, ArrayList, TreeMap etc.,


	-	Camel Notation		:	first word is in lowercase, from the second word onwards Pascal Notation
						eg: variable names, method names etc.,

						eg: indexOf(), lastIndexOf() etc.,
			
	-	Uppercase Notation	:	constants
	-	Lowercase Notation	:	package names
						eg: java.io, java.awt, java.util, java.lang etc.,


2)	operators
	-	arithmetic	:	+	-	*	/	%
	-	relational	:	>	<	==	>=	<=	!=
	-	logical		:	&&	||	!
	-	assignment	:	=	+=	-=	*=	/=	%=
	-	bit-wise 	:	&	|	~	>>	<<	^
	-	conditional operator :	(condition) ? true-statement : false-statement
	-	increment/decrement :	++	--
	-	special operators
		;	[]	
		+	string concatenation
		"instance of"	operator

3	keywords (reserved words)
	-	if, switch, for, int, float, long

4)	literals
	-	any fixed value that does not change during the program execution.

	numeric literals
	-	integer literals
		-	decimal		-	base 10		-	0 - 9		-	no prefix	
		-	binary		-	base 2		-	0,1		-	0b prefix
		-	octal		-	base 8		-	0-7		-	0  prefix
		-	hexa-decimal	-	base 16		-	0-9,A-F		-	0x prefix


	-	floating-point literals
		-	2.56
	
	non-numeric literals
	-	character literals
		-	single alphabet, single digit, single special symbol enclosed within single quotes
			eg:	'A'	'7'	'?'
	-	string literals
		-	group of characters enclosed within double quotes.
			eg:	"srinivas"	"49-53-20/25"	"9247175823"	"A"	"" (empty string literal)
	-	boolean literals
			true, false

	

5)	comments
	-	//		end-of-line comment	
	-	/* and */	block comment	
	-	/** and */	documentation comment




what is the difference?

	int a = 101;		--	decimal
	int b = 0101;		--	octal
	int c = 0b101		--	binary
	int d = 0x101		--	hexa


what is a constant?
	it is also known as symbollic constant.
	it is a name given to literal.
	whose value can never be changed in the program execution.
	constants can be defined using "final" keyword.


	double PI = 3.14;		// declaring a variable whose name is PI.
	final double PI = 3.14;		// declaring a constant whose name is PI



	final int MAX_MARKS = 100;
	final int PASS_MARKS = 35;

	PI, MAX_MARKS, PASS_MARKS are called constant
	3.14, 100, 35 are called literal.



	eg:
		double area = PI * radius * radius;



	double 		:	keyword
	a 		:	identifier
	= 		:	operator
	PI		:	constant
	*		:	operator
	r		:	identifier
	*		:	operator
	r		:	identitifer
	;		:	statement-terminator operator



what are the various data types?

primitive
	byte, short, int, long
	float, double
	char, boolean

non-primitive (user-defined)
	class, interface, enum, annotation


package:
	it is a collection of related classes, interfaces and sub packages.
	internally it is represented as a folder in O/S.


	reverse of the domain name.	

	www.virtue.com	→	com.virtue

	www.dxc.in	→	in.dxc



can main method be overloaded?
	YES.


can we change the signature of the main() ?
	we CAN NOT.


String[] args?
	called as command-line arguments.
	this is another way of taking inputs.


print all the values that are passed as command-line arguments?


arithmetic operations using command line arguments.



Wrapper classes:	(java.lang)
----------------------------------------
	to convert the String form data (data which is in string format)  back into corresponding primtive datatype.

	
class name		static method
---------------------------------------------------------
Integer			parseInt(String-form-int)
Double			parseDouble(String-form-double)
Float
Byte
Character
Boolean



	String str = "100";
	int a = Integer.parseInt(str);		// a = 100


	String str2 = "2.56";
	double b = Double.parseDouble(str2);	// b = 2.56


control structures	(control statements)
--------------------------------------------------
+	if, switch				(decision making)
+	for, while, do..while, enhanced for	(looping)
+	break, continue				(jump)
+	labelled break, labelled continue	



what is the difference between if and switch?
+	if is a bi-directional decision making statement.
	> , <, ==, >=, <= , !=
	int, long, float, double, byte, short, char, boolean

+	switch is a multi-directional decision making statement.
	only ==	(equality) comparisions
	illegal data types	:	float, double, boolean
	legal data types	:	char, byte, short, int, enum, String


for, while, do..while	-	statements are executed as long as the condition is true.

how to choose between for and while?
+	for loop is used to iterate set of statements for a finite number of times.
	where as while loop is used to iterate set of statements for an indefinite number of times. 

what is do..while loop?
+	to execute a loop atleast once irrespective of the condition.


what is the result of a condition?
	boolean value	-	true/false

what is the difference between break and continue?
+	whenever a break statement is encountered within any loop, the control immediately comes out of the loop 
	without executing remaining iterations.

+	whenever a continue statement is encountered within any loop, the control immediately go to the next iteration
	without executing remaining statements in the current iteration.


arrays:
-------
+	linear collection of homogeneous data items stored under single name.
+	in java, every array is an object.
+	it contain a special field (property) "length", that return no. of cells present in the array.
+	once declared, we cannot change the size of the array.	(static data structure)


types of arrays:
----------------
+	single dimension
+	multi  dimension
	-	every row contain same number of columns.
	-	every row is treated as a single dimension array

	1	2	3
	4	5	6
	7	8	9

+	jagged array
	-	every row contain different number of columns.

	1	2
	3	4	5
	6
	7	8	9	10


enhanced for:
-------------
	for(datatype  var : array/collection) {
		statement(s);
	}



what is the difference between for and enhanced for?
+	looping variable of the for loop is always int.
	in the for loop, we can skip few elements, we can traverse in reverse direction also.
	value of looping variable can be changed during the iteration.

+	looping variable in the enhanced for loop must be same as the type of array.
	enhanced for loop can traverse starting from the first element, one after the other, till the last element.
	looping variable cannot be changed in enhanced for loop.


1) accept a number. reverse it. print it.
	eg: input : 749
	ouput : 947

2) accept a number. print the sum of the digits it.
	eg: input : 749
	output : 20	(=9+4+7)

3) accept a number. print whether it is prime number or not.

4) accept a number. print whether it is palindrome or not.
	eg: input : 121
	    output : palindrome

5) accept a number. print whether it is armstrong or not.

	eg: input : 153
	output : 3^3 + 5^3 + 1^3 = 153	

6) fibonacci series


How do you write an infinite loop using for and while?

	for( ; true ; ) {
		System.out.println("Hello sowjanya");
	}

	(or)

	for ( ; ; ) {
		System.out.println("Hello sowjanya");
	}


	while (true) {
		System.out.println("Hello sowjanya");
	}




How do sort an array?

	Arrays.sort(arrayName);


java.util.Arrays  class:
---------------------------
1) equals(sarray-1, sarray-2)
2) sort(sarray)
3) toString(sarray)
4) binarySearch(sarray, key)

5) deepEquals(darray-1, darray-2)
6) deepToString(darray)


								String class
								-------------
							     (java.lang package)

java.lang 	►	default package
			means it is imported automatcially for every program.

			eg: String, System, Integer, Float, Double, Long, Boolean etc.,

java.lang.String:
-------------------
+	it is a pre-defined class
+	it is immutable (not modifiable)

declare:
--------

1) String str;
2) String str = "java";
	         0123
3) String str = new String();
4) String str = new String("hello");

methods:
--------
a) length()
b) charAt(index)
	str.charAt(0)		→	j
c) indexOf(String)
	str.indexOf("a");	→	1	(first occurance)
d) lastIndexOf(String)
	str.lastIndexOf("a")	→	3	(last occurance)
e) substring(start_index_inclusive  [, end_index_exclusive])
	str.substring(2,4)	→	va
f) startsWith()	→	str.startsWith("ja")	→	true
g) endsWith()	→	str.endsWith("va")	→	true
h) contains()	→	str.contains("a")	→	true
i) toUpperCase()	
j) toLowerCase()
k) concat()	→	to combine two string
l) replace(old_char, new_char)
m) trim()	→	remove both leading and trailing spaces.
n) equals()
o) equalsIgnoreCase()
p) compareTo()	→	to compare two strings	→	return 0 if both are equal, +ve value if string1 is big, -ve value if string2 is big
q) isEmpty()
r) toCharArray()
s) split(regex)

		
What is the difference between == and equals() ?

what is the difference between equals() and compareTo() ?


String str = "hello world";
how do you display "world" out of it.


what is the difference between the following statements?

	String str1 = new String("hello");
and	
	String str3 = "hello";


StringBuffer and StringBuilder:
---------------------------------
(java.lang)
+	peer classes of String class.
+	both are mutable (modifiable)


what is the diiference between StringBuffer and StringBuilder?
	StringBuffer is thread-safe.
	StringBuilder is not thread-safe.

methods:
--------
1) length()
2) capacity()
3) append(string)
4) insert(index, string)
5) replace(start index, end index, string)
6) delete(start_index_inclusive, end_index_exclusive)
7) reverse()



								functions
								---------
recursive functions
	calling a function being in itself.


call-by-value
	in case of primitive types, java follow call-by-value mechanism.
	changes are not reflected back.

call-by-reference
	changes are reflected back.



									OOPS
							(Object Oriented Programming System)
							------------------------------------

+	It is a programming paradigm (methodology)
	- monolithic 		(eg:  BASIC, Assembly Language)
	- procedure oriented	(eg:  COBOL)
	- structured		(eg: 'C')
	- object oriented	(eg: C++, Java, C#, Python, Ruby etc.,)


+	data is given importance than logic
+	simulate real world objects in the programming


class:	it is a user-defined datatype that represent an entity in terms of properties (data members) and behaviours (methods)
	it is a re-usable software component.
	classes we are creating are also known as POJO (Plain Old Java Object), models, beans, entity class etc.,
	no memory is allocated when we define a class.


	datatype		var	=	value

	int			x	=	45;
	double			y	=	2.6;


	eg: student, employee, person, account
	
object:		it is a run time instance of a class.
		(it is a variable whose data type is class)
		we have to use "new" keyword to create object for a class.

		memory is allocated only when we create an object for this class.

	datatype		var

	student			s1	=	new	student();

	(class)			(object)

	employee		e1 	=	new 	employee();


real world examples:
-----------------------------
Mobile class
	properties	:	color, model, manufacturer				(data members)	
	behaviours	:	calling(), browsing(), recording(), messaging()		(methods)


Refrigerator
	properties	:
	behaviour	:
TV
	properties	:
	behaviour	:

Washing Machine
	properties	:
	behaviour	:



advatnages of OOPS:
--------------------
+	code reusability
+	security


features of OOPS:
------------------
1) encapsulation	:	data hiding
2) abstraction		:	behaviour hiding


real world example:
------------------------
TV
	data hiding	:	closing all components inside a sealed unit
	encapsulation	:	providing some buttons/knobs to operate the TV.

	abstraction	:	internal operations are hidden.
	
CAR
	data hiding
	encapsulation	:	providing steering, accelrator, break, clutch
				(necessory components are exposed to drive the car)
	abstraction	:	internal mechansism is hidden



programs:
---------
7) matrix addition
8) matrix multiplication
9) matrix tranpose


[3] 3-jan-2022

varargs	(variable arguments):
-----------------------------
ellipsis ( ... ) symbol represent varargs.
whenever we have this symbol, we can pass any number of arguments to the function as comma-seperated list.


data member default values:
-------------------------------
int	►	0
double	►	0.0
String	►	null




access specifiers:
----------------------
1) private	►	members can be used only within the class in which they are defined.
			data members must be assigned always a private access. so that we can achieve "data hiding".

2) public	►	members can be accessed either within the class or from outside the class.
3) protected	►	members can be accessed either within the class or from any of it's sub class.
4) default	►	members (data members and methods) can be used either within the class or from any other class
			in the current package.


setters and getters:
---------------------
setters are used to modify the value of the property.
getters are used to retrieve the value of the property.
setters and getters both are not mandatory.

note:
-----
+	data members are stored independently for each object
+	methods are stored in a special memory, and it can be accessed for all objects of the class.
 


"this" reference:
-----------------
+	it represent an implied object.
+	implied object means the object which is invoking a method currently.


constructor:
------------
+	it is a special method and is automatically called whenever an object is created.
+	it should have the same name as that of class.
+	it can take parameters also.
+	it cannot return any value,and should not have the return type as void.
+	a class can have many constructors. (constructor overloading)


+	it is used to initialize data members.



Note:
-----
+	if a class do not have any constructor, java insert a default constructor for every class.
+	but if a class contain atleast one constructor, java do not insert the default constructor on it's own.



types of constructor:
-----------------------
+	default constructor 	(no-parameter | no-argument constructor)
+	parameter constructor	(parameterized | parametric)
+	copy constructor

copy constructor:
-------------------
+	it is a special constructor that takes object of the same class passed as parameter to the constructor.
+	it is used to inialize an object with another existing object.


static:
-------
static means "sharable".

static:
-------
it can be used in 4 ways.
a) static data members	(class variables)
	-	to store data which is common to all objects of the class.

	class	Product {
		private int productId;
		private String name;

		private static int tax;
	}

b) static methods
	-	they do not need any object to call.
	-	it can be called directly with the class name.
	-	allow only static data members or other static methods.


	
c) static block
	-	block is a group of statements enclosed within curly braces.
	-	it is the first code block that is executed in the program.
	-	it is executed automatically 
		-	whenever a static method is called
		-	whenever a static data member is accessed

	can we have multiple static blocks?
	-	we can have multiple static blocks.

d) static class
	-	we can use static keyword on inner class.


what are the legal access specifier for a class?
	public, default
	static	►	only for inner class

class A {

	static class B {

	}
}


Can I overload static methods?
+	YES

class Test {
	public static void show(int x) {
		System.out.println(x);
	}

	public static void show(double x) {
		System.out.println(x);	
	}
}

class TestApp {
	public static void main(String[] args) {
		Test.show(100);
		Test.show(5.6);
	}
}



inheritance:
------------
+	creating a new class (sub class) from an existing class (super class)
+	sub class can use all the features of super class as well as any extra features that are added to it.
+	using "extends" keyword we can achieve this
+	it represent an "is-A" relationship
+	it is mainly for code reusability.

types of inheritance:
----------------------
+	simple (single)
+	hierarchical
+	multi-level

+	multiple inheritance is not supported in java. to acheive this, we have to use interfaces.

	
super:
-------
+	super is used to access super class data members or super class methods from sub class.
		super.dataMember
		super.method(arg-1, arg-2, ...)

+	super is also used to call super class constructor from sub class constructor.
		super(arg-1, arg-2, ...)
	if used, super() call must be the first statement in the code block.



what is the difference between method overloading and method overriding?

method overloading:
--------------------
when two methods have the same name but with different parameter list.

method overriding:
-------------------
when a sub class contain a method that has same signature as that of another method in it's super class then the sub class method is said to be
overriding.

it is a best practice to use "@Override" annotation on overrided methods.
it is optional.
But if used, if the overriding is not done properly, compiler will give an error.


method signature	=	 method name + parameter list


class Test {

	public void show(int x) {
		System.out.println(x);
	}

	public void show(double x) {			// overloading
		System.out.println(x);
	}
}

class TestSub   extends  Test {
	@Override
	public void show(int x) {			// overriding		
		x++;
		System.out.println(x);
	}
}


java.lang.Object	class
------------------------------
+	it is universal super class (cosmic class)
+	every class in java, whether it is pre-defined or user-defined, they are inherited from java.lang.Object class.



methods:
--------
1) public String toString()
2) public boolean equals(Object o)
3) public Object clone()
4) public int hashCode()
5) protected void finalize() throws Throwable 




				person(name, age)
				
			
	Employee	(salary)			Student		(fee)

	Manager		(bonus)



constructor phenomenon:
-----------------------
	class  A {
		public A() {
			System.out.println("A - constructor");
		}

	}

	class	B	extends  A {

		public B() {
			System.out.println("B - constructor");
		}
	}


	class  Test {
		public static void main(String[] args) {
			B  obj = new B();
		}
	}


output:
-------
A - constructor
B - constructor


-------------------------------------------


	class	A {
		public A(int x) {
			System.out.println("A - value of x = " + x);
		}

	}

	class	B extends  A {
		public B(int y) {
			System.out.println("B - value of y = " + y);
		}
	}

	class Test {
		public static void main(String[] args) {
			B obj = new B(200);
		}
	}

output:
--------
	???


[4] 4-jan-2022


+	when an object is created, the constructor of that class is called.

+	when an object of sub class is created, super class constructor is called first and 
    	then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.

"super" keyword:	("super" reference)
----------------------------------------------------
	1) it is used to call the constructor of super class from the constructor of sub class.
	2) This is used exclusively call a parameter constructor or copy constructor of the 
        super class from sub class constructor.
	3) if super() has to be used, it must be the first statement in the code block.
	4) this() and super() cannot be used at a time.	(mutually exclusive)
	5) "super" keyword can be used to call an overriding function of super class in the sub class.


class	A {
	public A() {
		System.out.println("A - constructor");
	}

	public A(int x) {
		this();			// calling default constructor
		System.out.println("A - parameter constructor with x = " + x);
	}
}

class Test {
	public static void main(String[] args) {
		A  obj = new A(100);
	}
}

output:
-------
A - constructor
A - paramter constructor with x = 100



Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
abstraction means "behaviour hiding".
abstraction is "disclosing only required details and hiding the background implementation".

abstract class:
--------------------
	It is a class which should not have objects allocated.

	In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.

abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

   	
	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain any abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       	4) if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.


private	► protected ► default ► public



polymorphism:
	poly means many
	morph means forms

	exhibiting different behaviours for a same method call.

	move()	is known as polymorphic.				

	man	►	move()	►	walk
	fish	►	move()	►	swim
	bird	►	move()	►	fly
	snake	►	move()	►	crawl


	polymorphism
	+	compile-time polymorphism	(early binding)
		eg: method overloading

	+	run-time polymorphism		(late binding)
		eg: method overriding

note:
-----
	we can store object of a sub class in a super class reference variable.



Type Casting:
-------------
	Converting one datatype to another.

	2 types.

	a) Broadening	(promotion)		implicit
	b) Narrowing	(demotion)		explicit


	primitive types:
	-------------------
	a) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.0;		// error
	int x = (int)45.0;		// OK

	char ch = (char)156;	// OK


Referencing:
------------
       					     Employee
			                        |
            	-----------------------------------------------------------------
	        |					                        |
              Manager				                	ContractEmployee
	        |
       Managing Director


eg:
	Employee emp1 = new Employee();	
	Employee emp2 = new Manager();
	Employee emp3 = new ContractEmployee();	
	Employee emp4 = new ManagingDirector();
	Manager m2 = new ManagingDirector();	


	Manager m3 = new ContractEmployee();			// NP
	ContractEmployee ce = new Employee();			// NP



	user-defined data types:
	-----------------------------------------
	ContractEmployee ce2 = emp3;				// NP		

	ContractEmployee ce2 = (ContractEmployee)emp3	
	

	Manager m1 = (Manager)emp2;			
	Manager m2 = (Manager)emp3;			
	Manager m3 = (Manager)emp4;	


final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constant)

what is the opposite keyword of final?

	???


interface:
----------
+	It is a user-defined datatype but contain only public abstract methods and public static final variables.	(upto JDK 1.7)
+	It is mainly used to achieve multiple inheritance.
+	We can acheive 100% abstraction.

+	we cannot create object for an interface.
+	create a sub class (using implements keyword) and override all the abstract methods then create object for the sub class and use it.


class		►	extends		►	sub class
interface	►	implements	►	sub class
interface	►	extends		►	sub interface

class		►	NOT POSSIBLE 	►	sub interface

eg-1:
------

interface   B {

}

interface   C {

}
class	A	implements	B, C {

}


eg-2:
-----
class	X {

}

interface  Y {

}

class	Z   extends  X   implements  Y {

}

	

 								Built-In Packages
						                ------------------
                                        			(Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
    Date        (deprecated)
    Calendar    (deprecated)

java.io
    BufferedReader	


1) java.lang.System class:
   -------------------------------

	class variables			              	object
	-------------------				---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)		terminates the program then and there. int could be either a 0 or 1.
    


2) java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            	Math.sin(30)    =>  ???
            	Math.sin(Math.toRadians(30))    =>  0.5

        	double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            	Math.ceil(11.2) => 12
		floor() : return previous integer
            	Math.floor(11.9) => 11
		round() 
            	Math.round(11.2) =>  11
            	Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()



Boxing:
    converting primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   // auto-boxing

unBoxing:
    converting wrapper object back into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; 	// auto-unboxing


static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice



	

								Exception Handling
								------------------

Exception is an object that represents a situation where the application broke down.
Every Exception is a pre-defined class in Java.



   		java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException



Exception classes that are derived from java.lang.RuntimeException class - UNCHECKED
unchecked exceptions are not informed by the compiler.

All other are  								 - CHECKED


try, catch, finally
throw, throws

	
	1) try : contain the code where the exception can be generated.
    	2) catch : contain statements that are to be executed when the specified exception occurred in the correspoding try block
        3) finally : contain the code to be executed whether an exception or occurred or not.  

            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {				try {
                ..					...
            } finally {				} catch(ExceptionClassName excep) {
                ...					...
            }					}

    a try can have many catch blocks.
    a try block can have another try block within it.

    
note:
-----
+	we are not supposed to handle UnChecked Exceptions
        we have to avoid these exceptions using a technique called "Defensive programming".


+	if you do not handle checked exceptions, the compiler will give errors.
+	checked exceptions must be handled, they cannot be avoided.



User Defined Exceptions:
------------------------
1. create a class which should be derived from java.lang.Exception or java.lang.RuntimeException
2. write a constructor that takes a String parameter.
3. call the super class constructor by passing this String to it.


4. in the app,
	enclose the problamatic code inside a try block.
	raise the user defined exception using "throw" keyword.
	handle the user defined exception in the corresponding catch block.

throw keyword:
--------------
+	to raise an exception

throws keyword:
----------------
+	delegating the exception handling responsibility to the caller of the method.


JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   |  Exception-2  |  Exception-3    obj) {
	    statement(s)
    }


b) try-with-resources

    try (declare closable resources here....){
                    ........................
    } catch(....){

    }

    the closable resource will be close automatically.

    a Resource has to implement java.lang.Closable or java.lang.AutoClosable interface
    to be recognized as closable.


[5] 5-jan-2022


 								Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.

generics are implemented using angular brackes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.

1) generic methods

	public void sort(T[] arr) {
		// logic goes here ...
	}


2) generic classes

class  Test<T> {
	private:
		T   data;
	}
}



								Collection API   (java.util)
								----------------------------
								(Collection Framework)
API	►	Application Programming Interface

It is a collection of interfaces, abstract classes.
Java provided implementation classes also for Collection API.


Collections are divided into 3 parts:
a) declarations
b) implementations
c) algorithims



                               << Collection API Diagram >>

List
+	allow duplicate items
+	index-based operations are possible
+	nulls are allowed


	+	ArrayList
		-	is best when traversal is done more
		-	insertions and deletions are less
		-	internally use an expandable array
		-	it is not thread-safe

			add(), remove(), set(), size(), get(), iterator()
			clear(), isEmpty()

		what is the default capacity of an array list?
			10

		when we are trying to add 11 the element, the capacity is increased.
			newCapacity += oldCapacity + (oldCapacity >> 1)
	
		capacity is increased by 50%.
	

	+	LinkedList
		-	is best when insertions and deletions are frequently done.
		-	internally use a double-linked list.

			descendingIterator()
			
	
	+	Vector		(legacy class)



what is difference between iterator and list iterator?

how do you compare two arraylists whether they are equal or not?

what is the difference between arraylist and vector?
+	vector is a legacy class
+	it is a thread-safe (synchronized)
+	the default capacity for vector is 10.
+	the capacity is increased by 100%.



Set
+	do not allow duplicates
+	no index based operations are possible


	+ HashSet		:	uncertain order
	+ LinkedHashSet		:	insertion order
	+ TreeSet		:	sorted order


java.util.Collections class:
-------------------------------
	a) sort(arrayList)
	b) binarySearch()
	c) fill()

	

java.util.Comparable interface:
---------------------------------
	Employee class should be inherited from Comparable interface.
	
	public int compareTo(Employee o) {
		// logic goes here ..
	}


java.util.Comparator interface:	
--------------------------------
	Without disturbing the Employee class, other programmers can create their own comparators.


	public int compare(Employee o1, Employee o2) {
		// logic goes here ..
	}


what is the difference between Comparable and Comparator?
---------------------------------------------------------

		Comparable									Comparator
		----------									----------
1) Comparable provides a single sorting sequence. In other words, 		The Comparator provides multiple sorting sequences. 
   we can sort the collection on the basis of a single element 			In other words, we can sort the collection on the basis
   such as id, name, and price.	 						of multiple elements such as id, name, and price etc.

2) Comparable affects the original class, i.e., the actual class 		Comparator doesn't affect the original class, i.e., the 
   is modified.	  								actual class is not modified.

3) Comparable provides compareTo() method to sort elements.			Comparator provides compare() method to sort elements.

4) Comparable is present in java.lang package.					A Comparator is present in the java.util package.

5) We can sort the list elements of Comparable type by 				We can sort the list elements of Comparator type by 
   Collections.sort(List) method.						Collections.sort(List, Comparator) method.




[6] 6-Jan-2021


								Object Cloning
								--------------

The clone() method of java.lang.Object class creates a shallow copy of the object.

Here, the shallow copy means it creates a new object and copy all the fields and methods associated with the object.

The class should be inherited from Cloneable interface.
we have to override clone() method.



what is the difference between final, finally and finalize()?

	
+	finalize() is the method of Object class. 
+	This method is automatically called just before an object is garbage collected. 
+	finalize() method overrides to dispose system resources, perform clean-up activities and minimize memory leaks.


what is the contract between equals() and hashCode() ?

	when two objects are equal as per equals() method, the hash codes must be same.
	but the vice versa is not true.

	when ever you override equals() method, make sure that hashCode() is also override.



						Collection Part - 2
						--------------------
Map interface
+	it is used to store key-value pair of data.
+	key cannot be duplicated.
+	value can be duplicated.



+	HashMap		:	uncertain order
+	LinkedHashMap	:	insertion order
+	TreeMap		:	sorted order of key


put(key, value), get(key), keySet(), values(), containsKey(), containsValue()
entrySet()

Entry	►	key and value together.




						IOStream (java.io)
						------------------
stream : flow of data.

iostreams are used to store the data permanantly (in the form of files)

two types:
1) text stream	(character stream)
	-	to store any kind of information


	Reader
		FileReader
		BufferedReader
	Writer
		FileWriter
		PrintWriter

2) binary stream (byte stream)
	-	to store objects, audio, video, image

	InputStream
		FileInputStream
		ObjectInputStream
	OutputStream
		FileOutputStream
		ObjectOutputStream

serialization	:	storing (writing) object into a file
			the class should implement java.io.Serializable interface.
			Serializable interface is called as a null interface or marker interface (no methods to override)

			writeObject()

de-serialization :	reading object from a file.
			
			readObject()





								SQL
								---
							(Structured Query Language)
RDBMS	(Relational Database Management Systems)
----------------------------------------------------
eg:	Oracle, MySQL, Postgre SQL
	MS SQL Server, SQLite

SQL:
----
+	it is a non-procedural language
+	it is case insensitive
+	clauses must be written in different lines for readability.



SQL Commands:
---------------
+	DDL		(CREATE | ALTER | DROP | TRUNCATE | RENAME)
+	DML		(INSERT | UPDATE | DELETE)
+	DCL		(GRANT | REVOKE)
+	TCL		(COMMIT | ROLLBACK | SAVEPOINT)
+	DQL / DRL	(SELECT)


SQL Datatypes:
--------------
CHAR, VARCHAR, VARCHAR2, NUMBER, DATE
LONG, RAW, LONG RAW
CLOB  (Chacter Large Object), BLOB	(Binary Large Object)


What is the difference between Char and Varchar?
+	CHAR	-	fixed length, space padded
			max. is 2000

+	VARCHAR	-	varying length
			max. is 4000


char(10)	►	UMA......	►	10 bytes
varchar(10)	►	UMA		►	3  bytes


What is the difference between varchar and varchar2?
+	they are same.


What is normalization?
----------------------
It is the process of remove data redundancy and data inconsistency.


1 NF	:	no multi-valued columns
		identify the primary key column
2 NF
3 NF

4 NF
5 NF
BCNF

Integrity Constraints:
----------------------
These are conditions that are automatically verified by oracle server everytime you insert/update/delete data in a table.

+	NOT NULL
+	UNIQUE
+	CHECK (condition)
+	PRIMARY KEY
+	FOREIGN KEY	(REFERENCES)


+	DEFAULT


Primary Key:
+	It is used to identify each row uniquely in a table.
+	cannot be null
+	cannot be duplicated
+	a table can have only one primary key.


Foreign Key:
+	to establish relation from child table to parent table.
+	can be null
+	can be duplicated
+	a table can have more than one foreign key
+	every foreign key must be defined as a primary key or a unique key in the parent table.


CREATE   TABLE   dept
(deptno   number(3)   primary key,
 dname	  varchar2(20)
);

deptno = 10, dname = sales

INSERT  INTO  dept  VALUES  (10, 'sales');
INSERT  INTO  dept  VALUES  (20, 'purchase');



CREATE   TABLE   emp
(empno   number(3)    primary key,
 ename   varchar2(20),
 doj     date,
 salary  number(7,2)   check (salary >= 10000),
 deptno  number(3)  references dept(deptno)
);

empno = 101, ename = ramesh,  doj = 5 january 2022, salary 15000, deptno 10


INSERT  INTO  emp   VALUES  (101, 'ramesh', '5-jan-2022' , 15000, 10);
INSERT  INTO  emp   VALUES  (102, 'harkia', '4-jan-2022' , 17000, 10);
INSERT  INTO  emp   VALUES  (103, 'sreetu', '3-jan-2022' , 27000, 10);
INSERT  INTO  emp   VALUES  (104, 'lakshmi', '3-jan-2022' , 24000, 30);


UPDATE  emp   SET   salary = 17000  WHERE  empno = 101;

DELETE  FROM  emp   WHERE   empno = 104;

DELETE  FROM  emp   WHERE   doj = '3-jan-2022';




location	v	30


ALTER   TABLE   dept  ADD  location   varchar2(30);
ALTER   TABLE   emp   MODFIY  ename  varchar2(15);
ALTER   TABLE   emp   ADD  desg  varchar2(15);

ALTER   TABLE   dept  DROP  COLUMN location;

ALTER   TABLE   emp   DROP   (desg, doj);

ALTER   TABLE   emp   DROP  primary key;



Write a command to add a foreign key to an existing table?
How do you remove a foreign key?
How do you assign a check constraint for an existing table?


DELETE FROM dept;
TRUNCATE  TABLE  dept;

what is the difference between DELETE and TRUNCATE?


[7] 7-jan-2022

SELECT:
-------
	to retrieve from a table.
	we can perform all the following relational algebra operations using SELECT command.


relational algebra operations:
------------------------------
+	projection		(selecting few columns)
+	restriction 		(seleting few rows)
+	product
+	join
+	union
+	intersection
+	difference (minus)


syntax:
-------
SELECT	columnlist/*
FROM	tablename;

we can perform the following operations using SELECT command.
+	arithmetic expressions
+	column aliases		(should be enclosed within double quotes)
+	concatenated columns
+	literals		(should be enclosed within single quotes)


1) display monthly salary of all employees.

SELECT employee_id, first_name, salary, commission_pct, salary+(salary*commission_pct) 
FROM employees;


what is null?
+	when a column lack it's value then it is said to be null.
+	a null is not same as ZERO.
+	it is either unassigned, undetermined or unpredicted.
+	if any arithmetic operation is performed with null value, it leads to null result.

how to handle null values?
+	using NVL() library function

+	syntax:
		NVL(col/expr, non-null-value)


2) SELECT employee_id, first_name, salary, commission_pct, salary+(salary*NVL(commission_pct, 0)) 
FROM employees;


3) SELECT employee_id, first_name, salary, commission_pct, salary+(salary*NVL(commission_pct, 0)) AS "Monthly Salary" 
FROM employees;


4) display the full name of all employees.
	
SELECT   employee_id, first_name || last_name AS "Employee Name"
FROM     employees;


5) display the full name of all employees.

SELECT   employee_id, first_name || ' ' || last_name AS "Employee Name", salary+salary*nvl(commission_pct,0) AS "Monthly Salary"
FROM     employees;


WHERE clause:
--------------
	to filter the rows based on a criteria.

syntax:
-------
SELECT		columnlist/*
FROM		tablename
[WHERE		condition;]


operators:
---------
1) arithmetic operators	:	+	-	*	/
2) relational operators	:	>	<	=	>=	<=	!=  (or)  <>
3) logical operators	:	and	or	not
4) string concatenation opertors:	||
5) SQL operators
	a) BETWEEN	value-1  AND  value-2
	b) IN	(value-1, value-2, ...)
	c) LIKE	  'character pattern'
		i) %		replace 0 or more unknown characters
		ii) _		replace a single unknown character.
	d) IS  NULL
6) Negation Opeators
	a) NOT  BETWEEN	value-1  AND  value-2
	b) NOT  IN	(value-1, value-2, ...)
	c) NOT  LIKE	  'character pattern'
		i) %		replace 0 or more unknown characters
		ii) _		replace a single unknown character.
	d) IS  NOT NULL
	



6) display all employees who are working in department 50.

SELECT   first_name, department_id 
FROM   employees
WHERE  department_id = 50;

7) display all employees who earn salary is more than 15000.

SELECT   first_name, salary
FROM     employees
WHERE    salary > 15000;

8) display the details of Peter.

SELECT   employee_id, first_name, salary, commission_pct
FROM   employees
WHERE  first_name = 'Peter';


9) display all employees who are working in department 50 and earn salary more than 6000.

SELECT  employee_id, first_name, department_id, salary
FROM    employees
WHERE   department_id = 50
AND     salary > 6000;


10) display all employees who are either sales managers or earn salary less than 10000.

SELECT  employee_id, first_name, salary, job_id
FROM    employees
WHERE   job_id = 'SA_MAN' 
OR      salary < 10000;


11) display all employees except sales representatives.

SELECT  employee_id, first_name, job_id
FROM    employees
WHERE   job_id <> 'SA_REP';

(or)

...
...
...


12) display all employees who were hired on or before 15 nov 2004.

SELECT  employee_id, first_name, hire_date
FROM  employees
WHERE  hire_date <= '15-nov-2004';


13) display all employees who are working in department id 50 and who joined in the year 2005.

SELECT  employee_id, first_name, department_id, hire_date
FROM    employees
WHERE   department_id = 50
AND     hire_date >= '01-jan-2005' 
AND     hire_date <= '31-dec-2005';

(or)


SELECT  employee_id, first_name, department_id, hire_date
FROM    employees
WHERE   department_id = 50
AND     hire_date BETWEEN  '01-jan-2005'  AND  '31-dec-2005';






15) display all employees who are working department 10, 50, 70 and 90.

SELECT  employee_id, first_name, department_id
FROM    employees
WHERE   department_id IN  (10,50,70,90);


(or)

.....

16) display all employees whose first name begin with alphabet 'S'.

SELECT   employee_id, first_name
FROM     employees
WHERE    first_name like 'S%';


17) display all employees whose first name end with alphabet 'n'.

SELECT   employee_id, first_name
FROM     employees
WHERE    first_name like '%n';

18) display all employees whose first name contain alphabet 'n'.

SELECT   employee_id, first_name
FROM     employees
WHERE    first_name like '%n%';


19) display all employees whose first name contain second character as alphabet 'o'.


SELECT   employee_id, first_name
FROM     employees
WHERE    first_name like '_o%';


20) display all employees who were hired in the month of April in any year.

SELECT   employee_id, first_name, hire_date
FROM     employees
WHERE    hire_date like '%APR%';




21) display all employees who do not earn any commission.

SELECT  employee_id, first_name, commission_pct
FROM    employees
WHERE   commission_pct is null;


distinct qualifier:
-------------------
to eliminate duplicate rows in the output of the select command.

22) SELECT   distinct job_id
FROM     employees;

23) SELECT   distinct department_id
FROM     employees;

24) SELECT   distinct department_id, job_id
FROM     employees;


ORDER BY clause:
----------------
the order of retrieval of rows from the select command is always uncertain.
order by clause is used to retrieve in the ascending, descending, alphabetical or chronological order.
if used, it must be the last clause in the select command.


SELECT   columnlist/*
FROM     tablename
[WHERE   condition]
[ORDER   BY   col-1 [ ASC / DESC ]  [, col-2 [ASC / DESC], .... ] ];

25) display all employees in the increasing order of their salary.

SELECT  employee_id, first_name, salary
FROM    employees
ORDER   BY  salary  ASC;

26) display all employees as per their senioriy.

SELECT  employee_id, first_name, hire_date
FROM    employees
ORDER   BY  hire_date;


27) display all employees in the ascending order of department then by salary.

SELECT   employee_id, first_name, department_id, salary
FROM     employees
ORDER    BY   department_id, salary;



							Library Functions


1) number functions
2) character functions
3) date functions
4) conversion functions
5) group functions	(aggregate functions)


1) number functions:
	a) abs(col/val)
	b) power(col/val, col/val)
	c) sqrt(col/val)
	d) sin(col/val)
	e) cos(col/val)
	f) ceil(col/val)	: return next integer
	g) floor(col/val)	: return previous integer
	h) round(col/val)
	i) trunc(col/val)
DUAL:
-----
	it is a dummy table in oracle that contain only one row.
	
28)	select  abs(-25) from dual;
29)	select  power(5,3)  from dual;
30)	select ceil(11.89), floor(11.89), round(11.89567,2) from dual;

2) character functions
	a) length(col/val)
	b) upper(col/val)
	c) lower(col/val)
	d) initcap(col/val)
	e) instr(col/val, search_string)	: return the index of search_string in the col/val
	f) substr()


3) date functions

	sysdate : sydate is a pseudo column that return system date. internally it contain time also.

31)	select  sysdate  from dual;
	

	date arithmetic:
		date + n	= date
		date - n	= date
		date2 - date1	= n

32) 	display the hire date and probation date of all employees.
	the probation date is 180 days from their hire date.


	SELECT  employee_id, first_name, hire_date, hire_date+180 AS "Probation Date"
	FROM    employees;


33)	display the service of every employees.

	SELECT  employee_id, first_name, hire_date, trunc((sysdate - hire_date)/365) AS "Service in Years"
	FROM    employees;


	a) ADD_MONTHS(date, n)
	b) MONTHS_BETWEEN(date-1, date-2)

34) 	SELECT  employee_id, first_name, hire_date, trunc(months_between(sysdate, hire_date)/12) AS "Service in Years"
	FROM    employees;

	c) LAST_DAY(date)
	d) NEXT_DAY(date, 'weekdayname')

35)	SELECT  next_day(sysdate, 'friday')
	FROM    dual;	 



4) conversion functions:

	a) TO_CHAR(date, 'date picture')

	date pictures			description
		DD				
		MM
		YY
		YYYY

		MON
		MONTH

		DDD			julian day
		DAY			week day name

		hh
		mi
		ss

		am / pm			


		
36)	SELECT  TO_CHAR(sysdate, 'dd month yyyy') 
	FROM    dual;

37)	SELECT  employee_id, first_name, to_char(hire_date, 'dd-month-yy')
	FROM    employees;

38)	SELECT  to_char(sysdate, 'ddd')
	FROM    dual;

39)	SELECT  to_char(sysdate, 'day')
	FROM    dual;


40)	SELECT  to_char(sysdate, 'hh:mi:ss am')
	FROM    dual;

41)  	SELECT employee_id, first_name, to_char(hire_date, 'dd-month-yyyy hh:mi:ss am') 
	FROM   employees;


	b) TO_CHAR(number, 'number picture')

42)	SELECT  employee_id, first_name, salary, to_char(salary, '$99,999.99')
	FROM    employees;



[8] 8-jan-2022

group functions (aggregate functions):

+	sum(col/val)
+	avg(col/val)
+	min(col/val)
+	max(col/val)
+	count(col/val)

42) SELECT sum(salary), avg(salary), min(salary), max(salary)
    FROM   employees;

43) SELECT count(*)
    FROM   employees;

44) SELECT count(employee_id)
    FROM   employees;

45) SELECT count(salary), COUNT(commission_pct)
    FROM   employees;



GROUP BY clause:
+	It is used to divide the rows into groups and can extract summary information for each group.

syntax:
-------
SELECT	columnlist/*
FROM	tablename
[WHERE  condition]
[GROUP  BY  col-1 [ , col-2, col-3, ..] ]
[ORDER   BY   col-1 [ ASC / DESC ]  [, col-2 [ASC / DESC], .... ] ];


46) display total salary given to each department. 

SELECT   department_id, sum(salary)
FROM     employees
GROUP    BY   department_id
ORDER    BY   department_id;

47) display average salary of each designation.

SELECT   job_id, avg(salary)
FROM     employees
GROUP    BY   job_id;

48) display number of employees in each department.

SELECT   department_id, count(*)
FROM     employees
GROUP    BY   department_id;



HAVING clause:
--------------
+	this clause is used to filter the rows after grouping.
+	it is used always in conjunction with GROUP BY clause.

syntax:
------
SELECT	columnlist/*
FROM	tablename
[WHERE  condition]
[GROUP  BY  col-1 [ , col-2, col-3, ..] ]
[HAVING condition]
[ORDER   BY   col-1 [ ASC / DESC ]  [, col-2 [ASC / DESC], .... ] ];



49) display number of employees in each department if the department contain atleast 5 employees.

SELECT  department_id, count(*)
FROM    employees
GROUP   BY   department_id
HAVING  count(*) >= 5;


what is the difference between WHERE and HAVING?
+	WHERE clause used to filter the rows before grouping and
	HAVING clause used to filter the rows after grouping.


50) display total salary of each designation for all departments whose department id is more than 50.


SELECT  job_id, sum(salary)
FROM    employees
WHERE   department_id > 50
GROUP   BY  job_id
ORDER   BY  job_id;


51) groups within groups

display total salary of each job within each department.


main group	►	department id
sub group	►	job id

SELECT   department_id, job_id, sum(salary)
FROM     employees
GROUP    BY  department_id, job_id
ORDER    BY  department_id, job_id;



							JOINS
							-----
used to retrieve data from multiple related tables.
both the tables should have a common column.

types of joins:
1) equi join		(if the join condition is on equality)
2) non-equi join	(otherwise)


1) inner join		
2) outerjoin


SELECT   col-1, col-2, ...
FROM     table-1
NATURAL JOIN     table-2;

the natural join operation get data by comparing all common column(s) between two tables.


SELECT   col-1, col-2, ...
FROM     table-1
JOIN     table-2
USING    (common-column-name);

the USING clause specify the common column that should be used for comparing tables.

SELECT   col-1, col-2, ...
FROM     table-1
JOIN     table-2
ON       (join condition);



52) display employee id, first name and department name.

SELECT    employee_id, first_name, department_name
FROM      employees
JOIN      departments
USING     (department_id);

(or)

SELECT    employee_id, first_name, department_name
FROM      employees
JOIN      departments
ON        (employees.department_id = departments.department_id);

(or)

SELECT    employee_id, first_name, department_name
FROM      employees  E
JOIN      departments  D
ON        (E.department_id = D.department_id);

E and D are table aliases.



Three-Way Joins:
-----------------

53) display employee id, first name, department name and job title.

SELECT   employee_id, first_name, department_name, job_title
FROM     employees
JOIN     departments
USING    (department_id)
JOIN     jobs
USING    (job_id);

(or)


....



Four-Way joins:
------------------

54) display employee id, first name, department name, job title, city

SELECT  employee_id, first_name, department_name, job_title, city
FROM    employees
JOIN    departments
USING   (department_id)
JOIN    jobs
USING   (job_id)
JOIN    locations
USING   (location_id);


INNER  JOIN  : 
	will give only matching rows.
	


OUTER JOIN:
	it will display all matching rows as well any unmatched rows.

a) LEFT OUTER JOIN
b) RIGHT OUTER JOIN
c) FULL OUTER JOIN


55) 

SELECT  employee_id, first_name, department_name
FROM    employees
LEFT OUTER JOIN  departments
USING   (department_id);


56) 

SELECT  employee_id, first_name, department_id, department_name
FROM    employees
RIGHT OUTER JOIN  departments
USING   (department_id);


57) 

SELECT  employee_id, first_name, department_id, department_name
FROM    employees
FULL  OUTER JOIN  departments
USING   (department_id);


SELF  JOIN:
	joining a table to itself.



58) display the employee id, first name and his/her manager name.

SELECT  E.employee_id, E.first_name "employee name", M.first_name AS "manager name"
FROM    employees  E
JOIN    employees  M
ON      (E.manager_id = M.employee_id);




							SUB QUERY
							---------
+	it is also called as inner query or inner select or sub select.
+	the sub query is executed first then the result is passed to the outer query. outer query is executed that.


59) display the employee name who earn maximum salary.

SELECT  employee_id, first_name, salary
FROM  employees
WHERE salary = (SELECT max(salary)
FROM   employees);


60) display all employees who is having the same job as Neena.

SELECT  employee_id, first_name, job_title
FROM    employees
JOIN    jobs
USING   (job_id)
WHERE   job_id = (SELECT  job_id
FROM    employees
WHERE   first_name = 'Neena');

					

							CORRELATED SUB QUERY
							--------------------
+	this type of query is executed as many times as the number of rows in the outer query.
+	it will take one row from the outer query and go to the inner query and qualify the outer query for matching.
	if a match is found, the row is displayed otherwise it is ignored.
+	the above process is happened for each row in the outer query.

+	if the inner query contain a column that belongs to outer query in it's join condition then it is identified as 
	correlated sub query.


61) display all employees who earn more than the average salary in their department.

SELECT  employee_id, first_name, salary, department_id
FROM    employees E
WHERE   salary > (SELECT  avg(salary)
                  FROM    employees M
                  WHERE   M.department_id = E.department_id);

                  
								VIEWS
								-----
+	It is a virtual table, through which we can retrieve data from an underlying table known as 
	base table.
+	a view never contain any data on it's own.
+	it is stored as SELECT staments only.

+	it is mainly for security.
+	it is also used to reduce the repetetive typing of complex sql commands.


62) CREATE  OR REPLACE  VIEW   empid_first_name_view
AS
SELECT  employee_id, first_name
FROM    employees;


SELECT * FROM empid_first_name_view;


63) CREATE VIEW employee_details_view
AS
SELECT   employee_id, first_name, department_name, job_title, city, country_name
FROM     employees
JOIN     departments
USING    (department_id)
JOIN     jobs
USING    (job_id)
JOIN     locations
USING    (location_id)
JOIN     countries
USING    (country_id);


SELECT   * FROM  employee_details_view;


						SET OPERATIONS
						--------------
to combine two queries.


UNION
UNION ALL
INTERSECT
MINUS


64) SELECT  salary  FROM   employees   WHERE   department_id = 50
MINUS
SELECT  salary  FROM   employees   WHERE   department_id = 80;



						INDEX
						-----

it is meant for faster searching.
for every primary key column, a unique index is generated automatically by the oracle server.
this index is used whenever we perform querying on primary key.


65) CREATE  INDEX    department_id_index
ON   employees(department_id);


select * from employees where department_id > 50;


[9] 10-jan-2022


Top-N Analysis:
---------------
66) find the second highest salary.
67) display top 3 earners.
68) display top 3 senior employees.
69) display all employees who do not have any subordinates.
    (or)
    display all employees who are not managers.

       SELECT e.employee_id, e.first_name
       FROM employees e
       LEFT JOIN employees sub
       ON e.employee_id = sub.manager_id
       WHERE sub.manager_id IS NULL;

       (or)

       SELECT e.employee_id, e.first_name
       FROM employees e
       WHERE NOT EXISTS (SELECT 1
                         FROM employees e2
                         WHERE e2.manager_id = e.employee_id);



								PL/SQL
								------
+	PL/SQL stands for procedural language of SQL

+	we write PL/SQL blocks.
	+	anonymous block		(unnamed block)
	+	named block		(stored sub programs)

+	PL/SQL executor is responsible for executing PL statements.
+	SQL executor is responsible for executing SQL Commands.
+	PL/SQL block contain both SQL commands and PL constructs.


PL/SQL architecture:
[diagram]


PL/SQL datatypes:
-----------------
+	char, varchar, varchar2, number, date, boolean


declaring variables:
--------------------
	variable_name    :   datatype   [ :=   expr ];


anonymous block:
---------------
[DECLARE
	variable declarations]
BEGIN
	statement(s)
[EXCEPTION
     	WHEN   exception-id    THEN
		statement(s);]
END;


program-1:
-----------
declare
    first_number   number(3);
    second_number  number(3);
    result         number(3);

begin
    first_number := 10;
    second_number := 20;
    result := first_number + second_number;

    dbms_output.put_line('Sum = ' || result);
end;
/



SELECT statement in PL/SQL:
-----------------------------
SELECT   columnlist/*
INTO     var-1, var-2, ...
FROM     tablename
[WHERE   condition]
[GROUP   BY  col-1  [, col-2 ...] ]
[HAVING  condition]
[ORDER   BY  col-1  [ASC/DESC]  [, col-2 [ASC/DESC], ... ];


Note:
-----
+	select statement that return more number of rows cause an exception to be raised.	(TOO_MANY_ROWS)
+	select statenent that return no row cause an exception to be raised.			(NO_DATA_FOUND)



INTO phrase:
------------
It is a madatory phrase, used to store the data retrieved from the database in pl/sql variables.



program-2:
----------

write a pl/sql block to display the details of an employee whose id is 173.

declare
   v_employee_id   number(4);
   v_first_name    varchar2(10);
   v_salary        number(5);
begin
   SELECT   employee_id, first_name, salary
   INTO     v_employee_id, v_first_name, v_salary
   FROM     employees
   WHERE    employee_id = 173;

   dbms_output.put_line('Employee Id = ' || v_employee_id);
   dbms_output.put_line('First Name  = ' || v_first_name);
   dbms_output.put_line('Salary      = ' || v_salary);
end;
/


program-3:
----------
write a pl/sql block to display the details of an employee whose id is 501.


declare
   v_employee_id   number(4);
   v_first_name    varchar2(10);
   v_salary        number(5);
begin
   SELECT   employee_id, first_name, salary
   INTO     v_employee_id, v_first_name, v_salary
   FROM     employees
   WHERE    employee_id = 501;

   dbms_output.put_line('Employee Id = ' || v_employee_id);
   dbms_output.put_line('First Name  = ' || v_first_name);
   dbms_output.put_line('Salary      = ' || v_salary);
exception
   when  no_data_found  then
      dbms_output.put_line('No employee present with this id');
end;
/


program-4:
---------
write a program to display all sales managers.


declare
   v_employee_id   number(4);
   v_first_name    varchar2(10);
   v_job_id        varchar2(10);
   v_salary        number(5);
begin
   SELECT   employee_id, first_name, job_id, salary
   INTO     v_employee_id, v_first_name, v_job_id, v_salary
   FROM     employees
   WHERE    job_id = 'SA_MAN';

   dbms_output.put_line('Employee Id = ' || v_employee_id);
   dbms_output.put_line('First Name  = ' || v_first_name);
   dbms_output.put_line('Job Id = ' || v_job_id);
   dbms_output.put_line('Salary      = ' || v_salary);
exception
   when  no_data_found  then
      dbms_output.put_line('No employee present with this job id');
   when  too_many_rows  then
      dbms_output.put_line('More employees are there with this job id');
end;
/


cursor:
-------
+	it is a private sql area (special memory in the server) that hold all the rows retreved by the oracle server as
	the result of select statement from pl/sql block.

steps:
+	declare a cursor	(no memory is allocated, rather the query is parsed)
+	open the cursor		(associated sql command is executed, memory is allocated)
+	fetch one row at a time from the cursor and store the data in the pl/sql variables
+	do the above step until all rows are processed.
+	finally, close the cursor.


pl/sql attributes:
------------------

%type		to assign datatype of a column to pl/sql variable
%rowtype	to assign the entire record type


cursor attributes:
-----------------
%notfound	
%found
%isopen



program-5:
---------
write a program to display all sales managers.


declare
   v_employee_id   employees.employee_id%type;
   v_first_name    employees.first_name%type;
   v_job_id        employees.job_id%type;
   v_salary        employees.salary%type;

   CURSOR   cur_sales_manager
   IS
   SELECT   employee_id, first_name, job_id, salary
   FROM     employees
   WHERE    job_id = 'SA_MAN';


begin
   OPEN    cur_sales_manager;

   LOOP
      FETCH  cur_sales_manager  INTO  v_employee_id, v_first_name, v_job_id, v_salary;
      EXIT  WHEN  cur_sales_manager%NOTFOUND;

      dbms_output.put_line('Employee Id = ' || v_employee_id);
      dbms_output.put_line('First Name  = ' || v_first_name);
      dbms_output.put_line('Job Id = ' || v_job_id);
      dbms_output.put_line('Salary      = ' || v_salary);
   END LOOP;

   CLOSE   cur_sales_manager;
 
exception
   when  no_data_found  then
      dbms_output.put_line('No employee present with this job id');

end;
/


CURSOR FOR LOOP:
----------------
+	no need to open the cursor
+	no need to close the cursor
+	no need to fetch the data.
+	no need of declaring pl/sql variables to store the cursor data.


program-6:
---------
write a program to display all sales managers.


declare

   CURSOR   cur_sales_manager
   IS
   SELECT   employee_id, first_name, job_id, salary
   FROM     employees
   WHERE    job_id = 'SA_MAN';

begin

   FOR current_row  IN  cur_sales_manager
   LOOP
      dbms_output.put_line('Employee Id = ' || current_row.employee_id);
      dbms_output.put_line('First Name  = ' || current_row.first_name);
      dbms_output.put_line('Job Id = ' || current_row.job_id);
      dbms_output.put_line('Salary      = ' || current_row.salary);
   END LOOP;

exception
   when  no_data_found  then
      dbms_output.put_line('No employee present with this job id');

end;
/



PARAMETERIC CURSOR:
-------------------
+	no need to declare the cursor
+	no need to open the cursor
+	no need to close the cursor
+	no need to fetch the data.
+	no need of declaring pl/sql variables to store the cursor data.


program-6:
---------
write a program to display all sales managers.


begin

   FOR current_row  IN  ( SELECT   employee_id, first_name, job_id, salary
                          FROM     employees
                          WHERE    job_id = 'SA_MAN')
   LOOP
      dbms_output.put_line('Employee Id = ' || current_row.employee_id);
      dbms_output.put_line('First Name  = ' || current_row.first_name);
      dbms_output.put_line('Job Id = ' || current_row.job_id);
      dbms_output.put_line('Salary      = ' || current_row.salary);
   END LOOP;

exception
   when  no_data_found  then
      dbms_output.put_line('No employee present with this job id');

end;
/


stored sub programs:
	because these programs are stored in the database, they are called so.

	there are two types.

	a) stored procedure	(accept parameters but cannot return any value)
	b) stored function	(accept parameters but should return any value).


program-7:
-----------
write a stored procedure that will increase salary of all employees by given percentage.


CREATE  OR   REPLACE  PROCEDURE   proc_raise_salary(p_percentage   number)
IS
BEGIN
    update employees2
    set salary = salary + salary*p_percentage/100;
END;
/


execute proc_raise_salary;


program-8:
----------
write a stored function to return the average salary of a given department_id.

CREATE  OR  REPLACE  FUNCTION  fun_get_avg_salary(p_department_id  number)
RETURN  number
IS
    v_avg_salary   number(7,2);

BEGIN
    SELECT  avg(salary)
    INTO    v_avg_salary
    FROM    employees
    WHERE   department_id = p_department_id;
 
    RETURN  v_avg_salary;
END;
/


SELECT   fun_get_avg_salary(50)  from dual;


PACKAGE:
--------
	collection of related stored procedures and functions.

	every package will have two components.
	a) package specification (package declaration)
	b) package body


								Multi-Threading
								---------------
what is a thread?
+	it is a light weight process.
+	we can have multiple threads in a program using which we can perform multiple tasks parallelly.

how many ways?
+	by extending java.lang.Thread class
+	by implementing java.lang.Runnable interface?

constructors:
+	public Thread()
+	public Thread(Runnable)


why two ways?
+	if you want to create a thread on a sub class, we cannot use extends again.
+	here we have to use implements Runnable.


class 		A 	
{

}


class		B	extends		A   implements  Runnable {


}



what is a thread life cycle?
[diagram]

life cycle methods?
+	start()
+	stop()
+	run()		:	it contain statements related to the task
				it is executed automatically when we call start()

other methods:
wait()
notify()
sleep(milliseconds)
suspend()
yield()
resume()

currentThread()
setName()
getName()
getPriority()
setPriority()
getId()
isAlive()
setDaemon(boolean)


Thread priorities:
---------------------
It is an integer between 1 to 10.

1	MIN_PRIORITY
5	NORM_PRIORITY		(default priority)
10	MAX_PRIORITY


What is Daemon thread?
+	Daemon thread is abruptly terminated when no other threads are running.
+	It cannot run on its own.

setDaemon(true);


synchronization?
+	it is the capability to control the access of multiple threads to any shared resource.

+	synchronized method
+	synchronized block




							Concurrency API
							---------------
						    (java.util.concurrent)

ThreadPool
ExecutorService:
	it allow us to create a pool of threads.

	+	newFixedThreadPool(number_of_threads)





[10] 11-jan-2022

								ANT / Maven 
								-----------

It is a build tool.
It will create a .jar/.war file (Distributable file).

It can download all the third-party libraries. (dependencies).

xml 		
+	stands for extensible markup language
+	it is a data format that can used across different o/s
+	it is mainly used to store configuration data.


pom.xml	
+	pom stands "project object model"
+	it contain all dependencies, plug-ins and project related properties.



maven central repository	
+	this repo contain all the frequently used dependencies required for java developers.
+	the dependencies are copied from central repo to local repo (it is named as ".m2" folder)




								JDBC
							(Java Database Connectivity)

							      (java.sql)

Java APP	►	JDBC API	►	JDBC Driver Manager	►	JDBC Driver


JDBC API is implemented by DB Vendors like Oracle, MySQL etc.,

Oracle JDBC Driver	►	It is a collection of implementation classes of JDBC API (oracle implementation)
MySQL JDBC Driver	►	It is a collection of implementation classes of JDBC API (mysql community implementation)

These JDBC Drivers are available in the form of ".jar" files.




JDBC Drivers are 4 types.
1) Type-1 Driver	(JDBC-ODBC Bridge Driver)	-	It was not supported any more 
2) Type-2 Driver	
3) Type-3 Driver	
4) Type-4 Driver	(Thin Driver)


steps:
------
1) load the driver class	(this step is optional from jdk1.8)
2) establish connection
3) execute sql commands
4) finally close the connection.


JDBC API:
---------
+	DriverManager is absrtact class
	+	getConnection()

+	Connection interface
	+	Statement createStatement()
	+	PreparedStatement prepareStatement(sql)
	+	CallableStatement prepareCall(sql)
	
+	Statement interface	
	+	execute(sql)
	+	executeUpdate(sql)	: to execute INSERT/UPDATE/DELETE/CREATE
	+	executeQuery(sql)	: to execute SELECT


+	PreparedStatement interface
	+	it supports parameterized queries.

	+	execute()
	+	executeUpdate()		: to execute INSERT/UPDATE/DELETE/CREATE
	+	executeQuery()		: to execute SELECT
	

+	CallableStatement interface
	+	to call stored procedures / stored functions


+	ResultSet interface
	+	used to hold the data that is returned from the database as a result of executing SELECT command.





what is the difference between Statement and PreparedStatement?

		Statement									PreparedStatement
----------------------------------------------------------------------------------------------------------------------------------------------
1) It is used when SQL query is to be executed only once.			It is used when SQL query is to be executed multiple times.

2) You can not pass parameters at runtime.					You can pass parameters at runtime. (parameterized query)

3) Performance is very low.							Performance is better because it uses pre-compiled queries.

4) we can execute multiple sql commands using a single				we can execute only one sql command using a single 
   Statement object.								PreparedStatement object




	CallableStatement cs=con.prepareCall("{call procedure_name(?,?)}");  
	
	(or)

	CallableStatement cs=con.prepareCall("{? = call function_name(?,?)}");  



							

							HTML
							----
HTML	stands for Hyper Text Markup Language.

HTML		:	to design web pages

			important tags
			+	<b>, <i>, <sup>, <sub>, <strike>


what is a block element?
	it occupy 100% width of browser.
	eg: <h1> to <h6>
	    <p>
	    <hr>
	    <div>
	    <ul>, <ol>, <li>

what is an inline element?
	it occupy width of the element. not the browser width.

	eg: <b>, <i>, <span>, <u>, <strike>, <sup>, <sub>

what are sematic tags?
	eg: <strong>	
	    <em>
	    <del>


div and span?
	div is a container, which can have set of other html components.
	span is a place holder, in which we can place content dynamically.

what is ordered list, unorders list?

what are table related tags?
			
	<table>, <tr>, <th>, <td>
	<caption>
	<thead>, <tbody>, <tfoot>


	important attributes:
	+	rowspan
	+	colspan
	+	cellpadding
	+	cellspacing

what is anchor tag?


what is image tag?



what are form elements?
	<label>
	<input    type="text | radio | checkbox | file | password | button">
	<button>
	<textarea>
	<select> , <option>
			
			
	method attribute:
	+	get
	+	post

	action attribute:
	+	server program name to be executed when the user clicked on the submit button.




									CSS	
								(Cascading Style Sheet)


different types:
+	inline
+	internal (embedded)
+	external    (".css" file)
	-	<link  rel="stylesheet" href="sample.css" />

+	for styling the web page

+	selectors	
	+	id
	+ 	class
	+	element selector


+	pseudo selectors
	+	first-child
	+	last-child
	+	nth-child


media queries:
+	to achieve responsiveness.
+	@media



								Javascript
								----------
							(ECMASCRIPT 2015 - ES6)

Javascript	:	client side scripting language
			every browser will have javascript engine
			used to perform client side validations.
			javascript is dynamic language.



			document.getElementById()
			innerHTML
			value

Node JS		:	It is a server environment in which javascript programs can be executed.



	HTML element				Javascript Event

1) 	textbox					onblur
2) 	button, radio, check			onclick
3) 	select					onchange




								Bootstrap
								---------
It is a CSS library. It provide pre-defined CSS classes.
Only for designing responsive web pages.



								Java EE
								-------
							(Java Enterprise Edition)
Servlet:
+	Servlet is a web component that is deployed on the server to create dynamic web page.
+	Servlet API is provided by Java People.


+	Servlet API implementation is provided by Apache Tomcat, JBOSS etc.,



What is the difference between GET & POST?


Servlet Life cycle methods:
+	init()
+	service()
+	destroy()


ServletConfig	:	we will have one object for one user.
ServletContext	:	we will have only one ServletContext object for the entire application.



http://localhost:8081/ServletProject/



QueryString	(Request Parameters):
	url ? var-1 = value-1 & var-2 = value-2 & var-3 = value-3 ......


Session Management:
-------------------
http protocol is stateless.

session it a memory in the server given exclusively for one client.
session id, expiry time.


4 techniques:

1) hidden variables
2) url redirection
3) cookies
4) session





















































































	
















































 










































		


