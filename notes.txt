--------------------------------------------------------------------------------------------------------------------------------------------

D.Srinivas | dachepallisrinivas@gmail.com | 630 573 0633 (call/whatsapp)

--------------------------------------------------------------------------------------------------------------------------------------------
1) 30-dec-2021


Software links:
+	JDK 1.8
	https://www.oracle.com/in/java/technologies/javase/javase8u211-later-archive-downloads.html

+	Eclipse Enterprise Edition IDE
	https://www.eclipse.org/downloads/packages/release/neon/3/eclipse-ide-java-ee-developers

+	Oracle 11g express edition
	https://www.oracle.com/database/technologies/xe-prior-release-downloads.html





									Core Java
									----------

What is Java?
+	it is strictly, but partially object oriented programming language.

Who developed Java?
+	James Gosling at Sun microsystems (It was taken over by Oracle Corp.)


Features of Java:
-----------------
+	platform independent
+	robust
+	secured
+	object oriented



+	multi threaded
+	compiled-and-interpreted
+	dynamic
+	simple
+	high performance
+	distributed

1) platform independent?
+	here platform means O/S.



sample.java				sample.class

(source code)		compiler	(byte code)



bytecode can be given to any O/S, so that it can be executed.
is bytecode in 0's and 1's?	
	NO
bytecode is also an intermediate. it is not targeted to any O/S. it is targeted to JVM.
bytecode is understood only by JVM. (Java Virtual Machine)


sample.class			►	JVM	►	O/S
(byte code)					




what is JDK, JRE and JVM?

JDK 	►	Java Development Kit		
JRE	►	Java Runtime Environment
JVM	►	Java Virtual Machine


JDK = JRE + development tools
JRE = JVM + libraries 



development tools:
+	javac
+	java
+	etc.,


JRE will create JVM on-the-fly whenever a program is executed.
once the program is done, the JVM is removed.


is JDK platform independent?
NO

is JRE platform independent?
NO

is JVM platform independent?
NO


only the BYTECODE generated is PLATFORM INDEPENDENT.
the bytecode is given to jvm. jvm will convert the bytecode into native machine code (0's, 1's)


2) secured?
+	no explicit pointers
+	program is executed only inside a jvm.
	(jvm  collection of programs - class loader, bytecode verifier, garbage collector etc.,)


3) robust?
	robust means strong, vigour and healthy

+	strong type checking mechanism
+	exception handling
+	automatic memory management


Coding Standards (Best Practices)
+	indentation
+	naming convensions


Java Tokens?
+	smallest part of the program.
	a) identifiers
	b) operators
	c) keywords
	d) literals
	e) comments


1)	identifiers
	-	name given to variables, classes, methods etc.,

	-	Pascal Notation		:	first letter of every word in upper case and the rest in lower case
						eg: class names, interface names etc.,

						eg: ArrayIndexOutOfBoundsException, ArrayList, TreeMap etc.,


	-	Camel Notation		:	first word is in lowercase, from the second word onwards Pascal Notation
						eg: variable names, method names etc.,

						eg: indexOf(), lastIndexOf() etc.,
			
	-	Uppercase Notation	:	constants
	-	Lowercase Notation	:	package names
						eg: java.io, java.awt, java.util, java.lang etc.,


2)	operators
	-	arithmetic	:	+	-	*	/	%
	-	relational	:	>	<	==	>=	<=	!=
	-	logical		:	&&	||	!
	-	assignment	:	=	+=	-=	*=	/=	%=
	-	bit-wise 	:	&	|	~	>>	<<	^
	-	conditional operator :	(condition) ? true-statement : false-statement
	-	increment/decrement :	++	--
	-	special operators
		;	[]	
		+	string concatenation
		"instance of"	operator

3	keywords (reserved words)
	-	if, switch, for, int, float, long

4)	literals
	-	any fixed value that does not change during the program execution.

	numeric literals
	-	integer literals
		-	decimal		-	base 10		-	0 - 9		-	no prefix	
		-	binary		-	base 2		-	0,1		-	0b prefix
		-	octal		-	base 8		-	0-7		-	0  prefix
		-	hexa-decimal	-	base 16		-	0-9,A-F		-	0x prefix


	-	floating-point literals
		-	2.56
	
	non-numeric literals
	-	character literals
		-	single alphabet, single digit, single special symbol enclosed within single quotes
			eg:	'A'	'7'	'?'
	-	string literals
		-	group of characters enclosed within double quotes.
			eg:	"srinivas"	"49-53-20/25"	"9247175823"	"A"	"" (empty string literal)
	-	boolean literals
			true, false

	

5)	comments
	-	//		end-of-line comment	
	-	/* and */	block comment	
	-	/** and */	documentation comment




what is the difference?

	int a = 101;		--	decimal
	int b = 0101;		--	octal
	int c = 0b101		--	binary
	int d = 0x101		--	hexa


what is a constant?
	it is also known as symbollic constant.
	it is a name given to literal.
	whose value can never be changed in the program execution.
	constants can be defined using "final" keyword.


	final double PI = 3.14;
	final int MAX_MARKS = 100;
	final int PASS_MARKS = 35;

	PI, MAX_MARKS, PASS_MARKS are called constant
	3.14, 100, 35 are called literal.



	eg:
		double area = PI * radius * radius;



	double 		:	keyword
	a 		:	identifier
	= 		:	operator
	PI		:	constant
	*		:	operator
	r		:	identifier
	*		:	operator
	r		:	identitifer
	;		:	statement-terminator operator



what are the various data types?

primitive
	byte, short, int, long
	float, double
	char, boolean

non-primitive (user-defined)
	class, interface, enum, annotation


package:
	it is a collection of related classes, interfaces and sub packages.
	internally it is represented as a folder in O/S.


	reverse of the domain name.	

	www.virtue.com	→	com.virtue

	www.dxc.in	→	in.dxc



can main method be overloaded?
	YES.


can we change the signature of the main() ?
	we CAN NOT.


String[] args?
	called as command-line arguments.
	this is another way of taking inputs.


print all the values that are passed as command-line arguments?


arithmetic operations using command line arguments.



Wrapper classes:	(java.lang)
----------------------------------------
	to convert the String form data (data which is in string format)  back into corresponding primtive datatype.

	
class name		static method
---------------------------------------------------------
Integer			parseInt(String-form-int)
Double			parseDouble(String-form-double)
Float
Byte
Character
Boolean



	String str = "100";
	int a = Integer.parseInt(str);		// a = 100


	String str2 = "2.56";
	double b = Double.parseDouble(str2);	// b = 2.56


control structures	(control statements)
--------------------------------------------------
+	if, switch				(decision making)
+	for, while, do..while, enhanced for	(looping)
+	break, continue				(jump)
+	labelled break, labelled continue	



what is the difference between if and switch?
+	if is a bi-directional decision making statement.
	> , <, ==, >=, <= , !=
	int, long, float, double, byte, short, char, boolean

+	switch is a multi-directional decision making statement.
	only ==	(equality) comparisions
	illegal data types	:	float, double, boolean
	legal data types	:	char, byte, short, int, enum, String


for, while, do..while	-	statements are executed as long as the condition is true.

how to choose between for and while?
+	for loop is used to iterate set of statements for a finite number of times.
	where as while loop is used to iterate set of statements for an indefinite number of times. 

what is do..while loop?
+	to execute a loop atleast once irrespective of the condition.


what is the result of a condition?
	boolean value	-	true/false

what is the difference between break and continue?
+	whenever a break statement is encountered within any loop, the control immediately comes out of the loop 
	without executing remaining iterations.

+	whenever a continue statement is encountered within any loop, the control immediately go to the next iteration
	without executing remaining statements in the current iteration.


arrays:
-------
+	linear collection of homogeneous data items stored under single name.
+	in java, every array is an object.
+	it contain a special field (property) "length", that return no. of cells present in the array.
+	once declared, we cannot change the size of the array.	(static data structure)


types of arrays:
----------------
+	single dimension
+	multi  dimension
	-	every row contain same number of columns.
	-	every row is treated as a single dimension array

	1	2	3
	4	5	6
	7	8	9

+	jagged array
	-	every row contain different number of columns.

	1	2
	3	4	5
	6
	7	8	9	10


enhanced for:
-------------
	for(datatype  var : array/collection) {
		statement(s);
	}



what is the difference between for and enhanced for?
+	looping variable of the for loop is always int.
	in the for loop, we can skip few elements, we can traverse in reverse direction also.
	value of looping variable can be changed during the iteration.

+	looping variable in the enhanced for loop must be same as the type of array.
	enhanced for loop can traverse starting from the first element, one after the other, till the last element.
	looping variable cannot be changed in enhanced for loop.


1) accept a number. reverse it. print it.
	eg: input : 749
	ouput : 947

2) accept a number. print the sum of the digits it.
	eg: input : 749
	output : 20	(=9+4+7)

3) accept a number. print whether it is prime number or not.

4) accept a number. print whether it is palindrome or not.
	eg: input : 121
	    output : palindrome

5) accept a number. print whether it is armstrong or not.

	eg: input : 153
	output : 3^3 + 5^3 + 1^3 = 153	

6) fibonacci series


How do you write an infinite loop using for and while?

	for( ; true ; ) {
		System.out.println("Hello sowjanya");
	}

	(or)

	for ( ; ; ) {
		System.out.println("Hello sowjanya");
	}


	while (true) {
		System.out.println("Hello sowjanya");
	}




How do sort an array?

	Arrays.sort(arrayName);


java.util.Arrays  class:
---------------------------
1) equals(sarray-1, sarray-2)
2) sort(sarray)
3) toString(sarray)
4) binarySearch(sarray, key)

5) deepEquals(darray-1, darray-2)
6) deepToString(darray)


								String class
								-------------
							     (java.lang package)

java.lang 	►	default package
			means it is imported automatcially for every program.

			eg: String, System, Integer, Float, Double, Long, Boolean etc.,

java.lang.String:
-------------------
+	it is a pre-defined class
+	it is immutable (not modifiable)

declare:
--------

1) String str;
2) String str = "java";
	         0123
3) String str = new String();
4) String str = new String("hello");

methods:
--------
a) length()
b) charAt(index)
	str.charAt(0)		→	j
c) indexOf(String)
	str.indexOf("a");	→	1	(first occurance)
d) lastIndexOf(String)
	str.lastIndexOf("a")	→	3	(last occurance)
e) substring(start_index_inclusive  [, end_index_exclusive])
	str.substring(2,4)	→	va
f) startsWith()	→	str.startsWith("ja")	→	true
g) endsWith()	→	str.endsWith("va")	→	true
h) contains()	→	str.contains("a")	→	true
i) toUpperCase()	
j) toLowerCase()
k) concat()	→	to combine two string
l) replace(old_char, new_char)
m) trim()	→	remove both leading and trailing spaces.
n) equals()
o) equalsIgnoreCase()
p) compareTo()	→	to compare two strings	→	return 0 if both are equal, +ve value if string1 is big, -ve value if string2 is big
q) isEmpty()
r) toCharArray()
s) split(regex)

		
What is the difference between == and equals() ?

what is the difference between equals() and compareTo() ?


String str = "hello world";
how do you display "world" out of it.


what is the difference between the following statements?

	String str1 = new String("hello");
and	
	String str3 = "hello";


StringBuffer and StringBuilder:
---------------------------------
(java.lang)
+	peer classes of String class.
+	both are mutable (modifiable)


what is the diiference between StringBuffer and StringBuilder?
	StringBuffer is thread-safe.
	StringBuilder is not thread-safe.

methods:
--------
1) length()
2) capacity()
3) append(string)
4) insert(index, string)
5) replace(start index, end index, string)
6) delete(start_index_inclusive, end_index_exclusive)
7) reverse()



								functions
								---------
recursive functions
	calling a function being in itself.


call-by-value
	in case of primitive types, java follow call-by-value mechanism.
	changes are not reflected back.

call-by-reference
	changes are reflected back.



									OOPS
							(Object Oriented Programming System)
							------------------------------------

+	It is a programming paradigm (methodology)
	- monolithic 		(eg:  BASIC, Assembly Language)
	- procedure oriented	(eg:  COBOL)
	- structured		(eg: 'C')
	- object oriented	(eg: C++, Java, C#, Python, Ruby etc.,)


+	data is given importance than logic
+	simulate real world objects in the programming


class:	it is a user-defined datatype that represent an entity in terms of properties (data members) and behaviours (methods)
	it is a re-usable software component.
	classes we are creating are also known as POJO (Plain Old Java Object), models, beans, entity class etc.,
	no memory is allocated when we define a class.


	datatype		var	=	value

	int			x	=	45;
	double			y	=	2.6;


	eg: student, employee, person, account
	
object:		it is a run time instance of a class.
		(it is a variable whose data type is class)
		we have to use "new" keyword to create object for a class.

		memory is allocated only when we create an object for this class.

	datatype		var

	student			s1	=	new	student();

	(class)			(object)

	employee		e1 	=	new 	employee();


real world examples:
-----------------------------
Mobile class
	properties	:	color, model, manufacturer				(data members)	
	behaviours	:	calling(), browsing(), recording(), messaging()		(methods)


Refrigerator
	properties	:
	behaviour	:
TV
	properties	:
	behaviour	:

Washing Machine
	properties	:
	behaviour	:



advatnages of OOPS:
--------------------
+	code reusability
+	security


features of OOPS:
------------------
1) encapsulation	:	data hiding
2) abstraction		:	behaviour hiding


real world example:
------------------------
TV
	data hiding	:	closing all components inside a sealed unit
	encapsulation	:	providing some buttons/knobs to operate the TV.

	abstraction	:	internal operations are hidden.
	
CAR
	data hiding
	encapsulation	:	providing steering, accelrator, break, clutch
				(necessory components are exposed to drive the car)
	abstraction	:	internal mechansism is hidden



programs:
---------
7) matrix addition
8) matrix multiplication
9) matrix tranpose


[3] 3-jan-2022

varargs	(variable arguments):
-----------------------------
ellipsis ( ... ) symbol represent varargs.
whenever we have this symbol, we can pass any number of arguments to the function as comma-seperated list.


data member default values:
-------------------------------
int	►	0
double	►	0.0
String	►	null




access specifiers:
----------------------
1) private	►	members can be used only within the class in which they are defined.
			data members must be assigned always a private access. so that we can achieve "data hiding".

2) public	►	members can be accessed either within the class or from outside the class.
3) protected	►	members can be accessed either within the class or from any of it's sub class.
4) default	►	members (data members and methods) can be used either within the class or from any other class
			in the current package.


setters and getters:
---------------------
setters are used to modify the value of the property.
getters are used to retrieve the value of the property.
setters and getters both are not mandatory.

note:
-----
+	data members are stored independently for each object
+	methods are stored in a special memory, and it can be accessed for all objects of the class.
 


"this" reference:
-----------------
+	it represent an implied object.
+	implied object means the object which is invoking a method currently.


constructor:
------------
+	it is a special method and is automatically called whenever an object is created.
+	it should have the same name as that of class.
+	it can take parameters also.
+	it cannot return any value,and should not have the return type as void.
+	a class can have many constructors. (constructor overloading)


+	it is used to initialize data members.



Note:
-----
+	if a class do not have any constructor, java insert a default constructor for every class.
+	but if a class contain atleast one constructor, java do not insert the default constructor on it's own.



types of constructor:
-----------------------
+	default constructor 	(no-parameter | no-argument constructor)
+	parameter constructor	(parameterized | parametric)
+	copy constructor

copy constructor:
-------------------
+	it is a special constructor that takes object of the same class passed as parameter to the constructor.
+	it is used to inialize an object with another existing object.


static:
-------
static means "sharable".

static:
-------
it can be used in 4 ways.
a) static data members	(class variables)
	-	to store data which is common to all objects of the class.

	class	Product {
		private int productId;
		private String name;

		private static int tax;
	}

b) static methods
	-	they do not need any object to call.
	-	it can be called directly with the class name.
	-	allow only static data members or other static methods.


	
c) static block
	-	block is a group of statements enclosed within curly braces.
	-	it is the first code block that is executed in the program.
	-	it is executed automatically 
		-	whenever a static method is called
		-	whenever a static data member is accessed

	can we have multiple static blocks?
	-	we can have multiple static blocks.

d) static class
	-	we can use static keyword on inner class.


what are the legal access specifier for a class?
	public, default
	static	►	only for inner class

class A {

	static class B {

	}
}


Can I overload static methods?
+	YES

class Test {
	public static void show(int x) {
		System.out.println(x);
	}

	public static void show(double x) {
		System.out.println(x);	
	}
}

class TestApp {
	public static void main(String[] args) {
		Test.show(100);
		Test.show(5.6);
	}
}



inheritance:
------------
+	creating a new class (sub class) from an existing class (super class)
+	sub class can use all the features of super class as well as any extra features that are added to it.
+	using "extends" keyword we can achieve this
+	it represent an "is-A" relationship
+	it is mainly for code reusability.

types of inheritance:
----------------------
+	simple (single)
+	hierarchical
+	multi-level

+	multiple inheritance is not supported in java. to acheive this, we have to use interfaces.

	
super:
-------
+	super is used to access super class data members or super class methods from sub class.
		super.dataMember
		super.method(arg-1, arg-2, ...)

+	super is also used to call super class constructor from sub class constructor.
		super(arg-1, arg-2, ...)
	if used, super() call must be the first statement in the code block.



what is the difference between method overloading and method overriding?

method overloading:
--------------------
when two methods have the same name but with different parameter list.

method overriding:
-------------------
when a sub class contain a method that has same signature as that of another method in it's super class then the sub class method is said to be
overriding.

it is a best practice to use "@Override" annotation on overrided methods.
it is optional.
But if used, if the overriding is not done properly, compiler will give an error.


method signature	=	 method name + parameter list


class Test {

	public void show(int x) {
		System.out.println(x);
	}

	public void show(double x) {			// overloading
		System.out.println(x);
	}
}

class TestSub   extends  Test {
	@Override
	public void show(int x) {			// overriding		
		x++;
		System.out.println(x);
	}
}


java.lang.Object	class
------------------------------
+	it is universal super class (cosmic class)
+	every class in java, whether it is pre-defined or user-defined, they are inherited from java.lang.Object class.



methods:
--------
1) public String toString()



				person(name, age)
				
			
	Employee	(salary)			Student		(fee)

	Manager		(bonus)



constructor phenomenon:
-----------------------
	class  A {
		public A() {
			System.out.println("A - constructor");
		}

	}

	class	B	extends  A {

		public B() {
			System.out.println("B - constructor");
		}
	}


	class  Test {
		public static void main(String[] args) {
			B  obj = new B();
		}
	}


output:
-------
A - constructor
B - constructor


-------------------------------------------


	class	A {
		public A(int x) {
			System.out.println("A - value of x = " + x);
		}

	}

	class	B extends  A {
		public B(int y) {
			System.out.println("B - value of y = " + y);
		}
	}

	class Test {
		public static void main(String[] args) {
			B obj = new B(200);
		}
	}

output:
--------
	???


[4] 4-jan-2022


+	when an object is created, the constructor of that class is called.

+	when an object of sub class is created, super class constructor is called first and 
    	then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.

"super" keyword:	("super" reference)
----------------------------------------------------
	1) it is used to call the constructor of super class from the constructor of sub class.
	2) This is used exclusively call a parameter constructor or copy constructor of the 
        super class from sub class constructor.
	3) if super() has to be used, it must be the first statement in the code block.
	4) this() and super() cannot be used at a time.	(mutually exclusive)
	5) "super" keyword can be used to call an overriding function of super class in the sub class.


class	A {
	public A() {
		System.out.println("A - constructor");
	}

	public A(int x) {
		this();			// calling default constructor
		System.out.println("A - parameter constructor with x = " + x);
	}
}

class Test {
	public static void main(String[] args) {
		A  obj = new A(100);
	}
}

output:
-------
A - constructor
A - paramter constructor with x = 100



Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
abstraction means "behaviour hiding".
abstraction is "disclosing only required details and hiding the background implementation".

abstract class:
--------------------
	It is a class which should not have objects allocated.

	In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.

abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

   	
	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain any abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       	4) if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.


private	► protected ► default ► public



polymorphism:
	poly means many
	morph means forms

	exhibiting different behaviours for a same method call.

	move()	is known as polymorphic.				

	man	►	move()	►	walk
	fish	►	move()	►	swim
	bird	►	move()	►	fly
	snake	►	move()	►	crawl


	polymorphism
	+	compile-time polymorphism	(early binding)
		eg: method overloading

	+	run-time polymorphism		(late binding)
		eg: method overriding

note:
-----
	we can store object of a sub class in a super class reference variable.



Type Casting:
-------------
	Converting one datatype to another.

	2 types.

	a) Broadening	(promotion)		implicit
	b) Narrowing	(demotion)		explicit


	primitive types:
	-------------------
	a) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.0;		// error
	int x = (int)45.0;		// OK

	char ch = (char)156;	// OK


Referencing:
------------
       					     Employee
			                        |
            	-----------------------------------------------------------------
	        |					                        |
              Manager				                	ContractEmployee
	        |
       Managing Director


eg:
	Employee emp1 = new Employee();	
	Employee emp2 = new Manager();
	Employee emp3 = new ContractEmployee();	
	Employee emp4 = new ManagingDirector();
	Manager m2 = new ManagingDirector();	


	Manager m3 = new ContractEmployee();			// NP
	ContractEmployee ce = new Employee();			// NP



	user-defined data types:
	-----------------------------------------
	ContractEmployee ce2 = emp3;				// NP		

	ContractEmployee ce2 = (ContractEmployee)emp3	
	

	Manager m1 = (Manager)emp2;			
	Manager m2 = (Manager)emp3;			
	Manager m3 = (Manager)emp4;	


final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constant)

what is the opposite keyword of final?

	???


interface:
----------
+	It is a user-defined datatype but contain only public abstract methods and public static final variables.	(upto JDK 1.7)
+	It is mainly used to achieve multiple inheritance.
+	We can acheive 100% abstraction.

+	we cannot create object for an interface.
+	create a sub class (using implements keyword) and override all the abstract methods then create object for the sub class and use it.


class		►	extends		►	sub class
interface	►	implements	►	sub class
interface	►	extends		►	sub interface

class		►	NOT POSSIBLE 	►	sub interface

eg-1:
------

interface   B {

}

interface   C {

}
class	A	implements	B, C {

}


eg-2:
-----
class	X {

}

interface  Y {

}

class	Z   extends  X   implements  Y {

}

	

 								Built-In Packages
						                ------------------
                                        			(Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
    Date        (deprecated)
    Calendar    (deprecated)

java.io
    BufferedReader	


1) java.lang.System class:
   -------------------------------

	class variables			              	object
	-------------------				---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)		terminates the program then and there. int could be either a 0 or 1.
    


2) java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            	Math.sin(30)    =>  ???
            	Math.sin(Math.toRadians(30))    =>  0.5

        	double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            	Math.ceil(11.2) => 12
		floor() : return previous integer
            	Math.floor(11.9) => 11
		round() 
            	Math.round(11.2) =>  11
            	Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()



Boxing:
    converting primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   // auto-boxing

unBoxing:
    converting wrapper object back into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; 	// auto-unboxing


static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice



	

								Exception Handling
								------------------

Exception is an object that represents a situation where the application broke down.
Every Exception is a pre-defined class in Java.



   		java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException



Exception classes that are derived from java.lang.RuntimeException class - UNCHECKED
unchecked exceptions are not informed by the compiler.

All other are  								 - CHECKED


try, catch, finally
throw, throws

	
	1) try : contain the code where the exception can be generated.
    	2) catch : contain statements that are to be executed when the specified exception occurred in the correspoding try block
        3) finally : contain the code to be executed whether an exception or occurred or not.  

            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {				try {
                ..					...
            } finally {				} catch(ExceptionClassName excep) {
                ...					...
            }					}

    a try can have many catch blocks.
    a try block can have another try block within it.

    
note:
-----
+	we are not supposed to handle UnChecked Exceptions
        we have to avoid these exceptions using a technique called "Defensive programming".


+	if you do not handle checked exceptions, the compiler will give errors.
+	checked exceptions must be handled, they cannot be avoided.



User Defined Exceptions:
------------------------
1. create a class which should be derived from java.lang.Exception or java.lang.RuntimeException
2. write a constructor that takes a String parameter.
3. call the super class constructor by passing this String to it.


4. in the app,
	enclose the problamatic code inside a try block.
	raise the user defined exception using "throw" keyword.
	handle the user defined exception in the corresponding catch block.

throw keyword:
--------------
+	to raise an exception

throws keyword:
----------------
+	delegating the exception handling responsibility to the caller of the method.


JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   |  Exception-2  |  Exception-3    obj) {
	    statement(s)
    }


b) try-with-resources

    try (declare closable resourceses here....){
                    ........................
    } catch(....){

    }

    the closable resource will be close automatically.

    a Resource has to implement java.lang.Closable interface
    to be recognized as closable.


[5] 5-jan-2022


 								Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.

generics are implemented using angular brackes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.

1) generic methods

	public void sort(T[] arr) {
		// logic goes here ...
	}


2) generic classes

class  Test<T> {
	private:
		T   data;
	}
}



								Collection API   (java.util)
								----------------------------
								(Collection Framework)
API	►	Application Programming Interface

It is a collection of interfaces, abstract classes.
Java provided implementation classes also for Collection API.


Collections are divided into 3 parts:
a) declarations
b) implementations
c) algorithims



                               << Collection API Diagram >>

List
+	allow duplicate items
+	index-based operations are possible
+	nulls are allowed


	+	ArrayList
		-	is best when traversal is done more
		-	insertions and deletions are less
		-	internally use an expandable array
		-	it is not thread-safe

			add(), remove(), set(), size(), get(), iterator()
			clear(), isEmpty()

		what is the default capacity of an array list?
			10

		when we are trying to add 11 the element, the capacity is increased.
			newCapacity += oldCapacity + (oldCapacity >> 1)
	
		capacity is increased by 50%.
	

	+	LinkedList
		-	is best when insertions and deletions are frequently done.
		-	internally use a double-linked list.

			descendingIterator()
			
	
	+	Vector		(legacy class)



what is difference between iterator and list iterator?

how do you compare two arraylists whether they are equal or not?

what is the difference between arraylist and vector?
+	vector is a legacy class
+	it is a thread-safe (synchronized)
+	the default capacity for vector is 10.
+	the capacity is increased by 100%.



Set
+	do not allow duplicates
+	no index based operations are possible


	+ HashSet		:	uncertain order
	+ LinkedHashSet		:	insertion order
	+ TreeSet		:	sorted order


java.util.Collections class:
-------------------------------
	a) sort(arrayList)
	b) binarySearch()
	c) fill()

	

java.util.Comparable interface:
---------------------------------
	Employee class should be inherited from Comparable interface.
	
	public int compareTo(Employee o) {
		// logic goes here ..
	}


java.util.Comparator interface:	
--------------------------------
	Without disturbing the Employee class, other programmers can create their own comparators.


	public int compare(Employee o1, Employee o2) {
		// logic goes here ..
	}

what is the difference between Comparable and Comparator?
---------------------------------------------------------































		


